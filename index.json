[{"categories":["Cheatsheets"],"content":"A collection of random onliners and examples for usefull linux shell commands and functionality","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"Find Get the most recently modified file from a directory: find /path/to/target/dir -type f -exec ls -t1 {} + | head -1 Find the 10 largest files of a directory and its sub directories recursively: find / -type f -printf '%s %p\\n' | sort -nr | head -10 Find all files between 10Mb and 20Mb find / -type f -size +10M -size -20M Find all files created after 00:00:00 31.12.2020 find / -type f -newermt '2020-12-31' Find all files created before 00:00:00 31.12.2020 find / -type f ! -newermt '2020-12-31' Find and delete all files with the name special.txt and delete them find / -type f -regex \".*\\/special\\.txt\" -delete ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:1:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"Locate The locate command does not need to walk the whole file system to locate a file you search for. It uses a database which can be updated by the following command: sudo updatedb After that you can use search strings with wildcards to locate specific files like this: locate *.conf One drawback, in comparison to find, is that it does not provide as many search filters. ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:2:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"column To view multi line output formatted as table you can use the column command with the -t flag. For example, we want to view the inode number and the name of every file in a directory. Without column the output looks like this: ls -i 876080 g5.txt 876077 h1.txt 876078 h2.txt 876079 h3.txt 876081 h4.txt 876076 specific.special we can pipe it into column -t to format it: ls -i | column -t 876080 g5.txt 876077 h1.txt 876078 h2.txt 876079 h3.txt 876081 h4.txt 876076 specific.special ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:3:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"awk Using netstat list all services listening on all interfaces (0.0.0.0) for IPv4: netstat -luntp | grep \"LISTEN\" | awk '$4 ~ /0\\.0\\.0\\.0*/' | column -t ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:4:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"grep ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:5:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"regex To use the patterns run grep with the -E flag for extended regex Operator Description (a) The round brackets are used to group parts of a regex. Within the brackets, you can define further patterns which should be processed together. [a-z] The square brackets are used to define character classes. Inside the brackets, you can specify a list of characters to search for. {1,10} The curly brackets are used to define quantifiers. Inside the brackets, you can specify a number or a range that indicates how often a previous pattern should be repeated. | Also called the OR operator and shows results when one of the two expressions matches .* Also called the AND operator and displayed results only if both expressions match ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:5:1","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"systemctl Nice looking list of all services systemctl list-units --type=service Add Service to SysV to start automatically systemctl enable \u003cservice-name\u003e ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:6:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"Background a process It is possible to suspend process execution and send it to the background by pressing Ctr-z to send a SIGSTP signal to the kernel which suspends the process. We can resume execution by running the fg command which puts the process back to the foreground. This can come in handy if you are in your text editor and just want to quickly switch out of it, run a command and then switch back to it. You can also start a process which will run in the background and send its result to your shell as soon as it exits by adding a \u0026 to the end: ping -c 10 https://www.google.com \u0026 ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:6:1","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"rsync Transfer files from a directory, keeping file attributes like permissions, using compression for quicker transmission and ssh for encrypted transport: rsync -az -e ssh /path/to/local/dir user@server:/path/of/remote/dir ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:6:2","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"mount List all mounted drives: mount Mount a Usb stick to the local filesystem to the directory /mnt/usb: mount /dev/sdb1 /mnt/usb Unmount the Usb stick: unmount /mnt/usb ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:6:3","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"ifconfig Assign net mask to a network interface sudo ifconfig eth0 netmask 255.255.255.0 Assign an IP address to a network interface sudo ifconfig eth0 192.168.10.2 ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:7:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"route Set the address default gateway for a network interface to be used to send traffic outside the current network the interface is connected to sudo route add default gw 192.68.10.1 eth0 ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:8:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Cheatsheets"],"content":"Keyboard Shortcuts CTRL-a move the cursor to the beginning of the current line CTRL-e move the cursor to the end of the current line CTRL-\u003cleft-arrow|right-arrow\u003e jump to the beginning of the current/previous word ALT-B jump back one word ALT-F jump one word forward CTRL-R search through the command history CTRL-u erase everything from the current position of the cursor to the beginning if the line CTRL-k erase everything from the current position of the cursor to the end of the line CTRL-w erase the word preceding the cursor position ","date":"2023-11-22","objectID":"/2023/11/linux-shell-foo/:9:0","tags":["Cheatsheet","Linux","Shell"],"title":"Linux Shell Foo","uri":"/2023/11/linux-shell-foo/"},{"categories":["Docs"],"content":"A overview over the basics of Intel x86 Assembly and its most relevant instructions","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"This is an overview over the relevant basics of Intel’s x86 Assembly language. ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:0:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Architecture follows Van Neuman architecture Hardware components: CPU, RAM, I/O bitness: little endian Figure 1. Simplified Hardware Layout ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:1:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Main Memory Layout Data: also called data section, put in place when the program is initially loaded, the values contained in data may not be changed (static) and are available to every part of the program (global) Code: includes the instructions fetched by the CPU to execute the program, controls how the program’s tasks are orchestrated Heap: is used for dynamic memory during execution, changes frequently while the program is running Stack: is used for local variables and function parameters, helps control flow Figure 2. Simplified memory layout ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:2:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Syntax Most instructions are invoked in this format: Mnemonic Destination Source mov ecx 0x42 each instruction corresponds to opcodes ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:3:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Operands operands are used to identify data used by instructions there are 3 types of operands: Immediate operands: fixed values such as 0x42 in the Syntax example Register operands: refer to registers, for example ecx Memory address operands: refer to a memory address which contains value of interest, typically denoted with a value, register or equation in bracktes, like [eax] ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:4:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Registers small amounts of data storage available to the CPU can be accessed more quickly than storage available elsewhere registers on x86 fall into four categories: General registers: used by the CPU during execution Segment registers: used to track sections of memory Status Flags: used to make decisions Instruction Pointers: are used to keep track of the next instruction to execute ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"General Registers EAX (AX AH AL) EBX (BX BH BL) ECX (CX CH CL) EDX (DX DH DL) EBP (BP) ESP (SP) ESI (SI) general registers can either be accessed by their full name to retrieve the full 32-bit of data, but they can also be accessed in 16-bit mode, for example use EDX for all 32-bits in the register and DX to reference the lower 16-bits of the register four of the general registers (EAX, EBX, ECX and EDX) can also be referenced as 8-bit values, for example AL is used to reference the lowest 8-bits of EAX and AH is used to reference the second set of 8-bits, contained in the 16-bit register AX some instructions in x86 use specific registers, for example multiplication and division always use EAX and EDX if general registers are used in a consistent fashion across a program this is known as a convention, knowing different conventions used by different compilers can be helpful during analysis, for example EAX is commonly used to store the return value of a function, so if you see an operation on the EAX register after a call you can assume the return value is manipulated/used further in the code ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:1","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Segment Registers CS SS DS ES FS GS ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:2","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Status Registers EFLAGS the EFLAGS register is a 32-bit status register every bit in it is a flag, it can be set (1) or cleared (0) Figure 3. Layout of the EFLAGS register some important flags: ZF: the Zero Flag is set if the result of an operation is equal to zero, otherwise it is cleared CF: the Carry Flag is set if the result of an operation is too large or too small for the destination operand, otherwise it is cleared SF: the Sign Flag is set when the result of an operation is negative or cleared when the result is positive; is also set when the most significant bit is set after an arithmetic operation TF: the Trap Flag is used for debugging, if the flag is set the x86 processor will only execute one instruction at a time ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:3","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Instruction Pointer EIP also known as instruction pointer or program counter in x86 it is used to store the memory address of the next instruction to be executed tells the processor what to do next ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:4","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Instructions A list of some of the most important instructions, what they do and their syntax. ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"mov used to move data from one location to another Instruction Description mov eax, ebx Copies the content of EBX into the EAX register mov eax, 0x42 Copies the the value 0x42 into the EAX register mov eax, [0x4037C4] Copies the 4 bytes at the memory location 0x4037C4 into the EAX register mov eax, [ebx] Copies the 4 bytes at the memory location specified by the EBX register into the EAX register mov eax, [ebx+esi*4] Copies the 4 bytes at the memory location specified by the result of the equation ebx+esi*4 into the EAX register ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:1","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"lea load effective address format: lea destination, source used to put a memory address into the destination in contrast to mov which moves the content at memory location into the destination example: lea eax, [ebx+8] will put ebx+8 into EAX, while mov eax, [ebx+8] loads the data at the memory address specified by ebx+8 into EAX Figure 4. Difference between mov and lea ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:2","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Arithmetic Addition and Subtraction Instruction Description sub eax, 0x10 Subtracts 0x10 from EAX add eax, ebx Adds EBX to EAX and stores the result in EAX inc edx Increments EDX by 1 dec edx Decrements ECX by 1 Multiplication and Division both always act on predefined registers this requires correct setup of the related registers before the us of the mul or div instructions the syntax for the instruction is mul/div value, as the registers used are already predefined mul and div operate on unsigned value, imul and idiv are their equivalents for operations on signed values Instruction Description mul 0x50 Multiplies EAX by 0x50 and stores the result in EDX:EAX div 0x75 Divides EDX:EAX by 0x75 and stores the result in EAX and the remainder in EDX Multiplication mul always multiplies EAX with the provided value, so EAX needs to be setup correctly before the instruction the result is store as a 64-bit value across EDX and EAX EDX stores the 32 most significant bits and EAX the least significant bits of the return value Division div divides the 64-bits stored across EDX and EAX by value both EDX and EAX must be setup correctly for the use of the instruction the result of the division is stored in EAX and the remainder in EDX the remainder can be accessed with the modulo operator, which will access EDX after running div Logical Operators AND, OR, XOR, SHL, SHR, ROR, ROL for example work like add and sub, perform operation between specified source and destination and storing the result in destination xor can be used as an optimization by the compiler to set a register to 0 by xor it with itself, like xor eax, eax to set EAX to 0, as the instruction only requires 2 bytes instead of 5 for an equivalent mov instruction shl and shr are used to shift registers, their format is shr/shl destination, count they shift the bits in destination left (shl) or right (shr) by the number of bits specified by count bits shifted beyond the boundary are first shifted into CF (Carry Flag Bit), zero bits in the destination are filled in, so after the instruction CF contains the last bit shifted beyond the boundary in comparison ror and rol shift the destination and append the bits going over the boundary are rotated to the other site Instruction Description xor eax, eax Clears the EAX register or eax, 0x7575 Perform the logical or operation on EAX with 0x7575 shl eax, 2 Shifts EAX register to the left 2 bits ror bl, 2 Rotates the BL register to the right 2 bits, fall-off bits will be rotated in to the right ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:3","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Learning"],"content":"My write up for the analysis of Lab 3 from the first chaptr of Practical Malware Analysis","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"This lab turned out to be a bit more complicated than the two before. I spend a considerable amount of time figuring out how to unpack the provided sample, partly due to problems with setting up the tooling I wanted to use correctly (python3.10 backwards compatability can be a bitch). In addition to PE Bear and Detect it easy I used PEiD to identify the packer and a tool I found called unipacker. More about that later in the post. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:0:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Questions Are there any signature detections on VT ? Are there indicators for packing or obfuscation ? If so, unpack/de-obfuscate the sample. Do any imports hint at the samples functionality ? If so which imports are they and what do they tell you ? What host-based or network-based indicators could be used to identify this malware on infected machines ? ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:1:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Initial analysis As I did with the two samples before I ran Detect it easy against the provided sample. There were a few things I noticed intriguing. There were no signatures detected for a compiler or linker The time stamp showed as 1970-01-01 01:00:00, a sign that it was tempered with Detect it easy also couldn’t extract any information on imports from the sample ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Extracted Hashes MD5 9c5c27494c28ed0b14853b346b113145 SHA1 290ab6f431f46547db2628c494ce615d6061ceb8 SHA256 7983a582939924c70e3da2da80fd3352ebc90de7b8c4c427d484ff4f050f0aec ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Imports The only imports found by PE Bear are LoadLibraryA and GetProcAddress from kernel32.dll. These are used for importing DLLs and their functionality. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Is it packed ? These discoveries made me take a look at the sample with PEiD, a program used to detect common packing formats on binaries. Figure 1. PEiD packer detection As we can see from the output, the sample is indeed packed. The packer used is called FSG. After a little bit of research I found this article which describes how to unpack an executbale packed with FSG with the help of a debugger. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:3","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"How FSG works I am still in the phase of getting started with learning the concepts of x86 assembly so alot of this still went over my head, but I am trying to describe what I took from the article. The article describes that the first instructions of the program is an xchg, which is used to make the stack pointer (ESP) to a DWORD, in the case of the article at offset 4094E8h. This DWORD is 4094CCh, which points the stack pointer to a segment containing additional data. After the first xchg instruction the two values on top of the stack are 00401000h and 00407000h. After the xchg the next instruction is a popa. This instructions pops values of the stack into the general purpose registers. popa ,which is the next instruction, is used to pop WORD sized, so 16bit, values into the subregisters of the general purpose registers. The order in which the sub regsiters are filled in this case are: DI SI BP BX and so on. So in case of the prgram we look at in the article means that the lower 16 bit of the EDI and ESI registers will be set with the values on top of the stack. Researching those registers online (and by going ahead a bit in the book) I found out that those regsiters are often used with rep instructions, such as movsb. These instructions are used to automatically move a bunch of bytes from one buffer to another. This matches with the functionality further explained by the article. It states, that EDI and ESI are used to move bytes between two segments delimited by the two addresses in the registers after the popa, 00401000h and 00407000h. It is also stated that in case of the sample looked at in the article, this goes on until the first segment contains the names of the DLLs and their exports used by the program. After that LoadLibraryA and GetProcAddress are used to actually import them. This unveils the actual functionality of the program. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:4","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"So, can we unpack it ? During my research about FSG I found that most of the things which came up are actual write-ups or videos about this lab. Because it felt like cheating to me at first I left those alone. But after reading up on the packer I was curious to find out what the unpacked version of the sample actually does. I found this video which demonstrates the usage of a tool written in python called unipacker for which the code can be found here Unipacker uses emulation to, like a debugger, step through a program for unpacking. It is based on Capstone one of the biggest disassembler library out there. It is also used in a lot of other tooling. The use of the tool condenses the effort of unpacking the sample down to three instructions provided to unipacker. My assumption is that it steps through the program until the data moving and importing part is over and extracts the resulting PE from it, reconstructing the actual import table. After some struggles with getting it to run with python3.10 I used pyenv to install python3.8 to my environment and unipacker ran without problems. As python3.10 moved some imports from one module of the stdlib to another alot of older python code ran under 3.10 breaks on these older imports. I encountered the same problem with some older code at work. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:2:5","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"The unpacked Sample This section will be kept short. I used the usual tools to collect static information from the unpacked sample. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:3:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Hashes MD5 0b828a7ccf370a5c9d5ca4bcba6dbebe SHA1 08f610cd9d694fc08fe12356001d07bf2600c8ec SHA256 0fd9f5bcacddc526091630e269de92c50da8b7e85186d68a75418cade20475be ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:3:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Strings Offset Size Type String 0000004d 10 A !Windows Program 0000020f 07 A `.rdata 00000237 06 A @.data 00000e2e 05 A $s3 00000f34 0c A KERNEL32.dll 00000f42 0c A LoadLibraryA 00000f50 0e A GetProcAddress 00001013 05 A Phh @ 0000106e 06 A L$$QVP 00002167 09 A ole32.dll 00002171 0d A OleInitialize 0000217f 10 A CoCreateInstance 00002190 0f A OleUninitialize 000021a5 0c A OLEAUT32.dll 000021c9 0a A MSVCRT.dll 000021d4 0d A __getmainargs 000021e2 0a A _controlfp 000021ed 10 A _except_handler3 000021fe 0e A __set_app_type 0000220d 0a A __p__fmode 00002218 0c A __p__commode 00002225 05 A _exit 0000222b 0b A _XcptFilter 0000223c 0d A __p___initenv 0000224a 09 A _initterm 00002254 10 A __setusermatherr 00002265 0c A _adjust_fdiv 00003010 2a U http://www.malwareanalysisbook.com/ad.html 00004015 05 A Ph8j 00004025 05 A 3Bt\u003eO 00004042 06 A 2]\u003c,M 00004089 07 A S\u003eVWe 000040ca 05 A \"Z,Y 000040e6 05 A 5pg 00004133 06 A @^J% 00004144 06 A I*G9\u003e 000041b3 07 A \u003cd,Ll 000041c5 08 A ole32.vd 000041d1 05 A Init 000041ec 05 A U!!C 000041f4 09 A }OLEAUTLA 0000420a 0a A IMSVCRTT\"b 00004215 07 A _getmas 0000421d 07 A yrcsco 00004228 06 A fpex 00004235 07 A |P2r3Us 0000423f 05 A p|vuy 00004260 05 A rh# 0000502e 05 A $s3 00005134 0c A KERNEL32.dll 00005142 0c A LoadLibraryA 00005150 0e A GetProcAddress 00009050 09 A ole32.dll 0000905a 0c A OLEAUT32.dll 00009067 0a A MSVCRT.dll 000090a0 0d A OleInitialize 000090b0 10 A CoCreateInstance 000090c3 0f A OleUninitialize 00009145 0d A __getmainargs 00009155 0a A _controlfp 00009162 10 A _except_handler3 00009175 0e A __set_app_type 00009186 0a A __p__fmode 00009193 0c A __p__commode 000091a2 05 A _exit 000091aa 0b A _XcptFilter 000091bf 0d A __p___initenv 000091cf 09 A _initterm 000091db 10 A __setusermatherr 000091ee 0c A _adjust_fdiv ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:3:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Imports The unpacked sample contains imports from ole32.dll and oleauth32.dll. Those are libraries used for the management and manipulation of COM objects. COM or Component Object Model is a standard for binary interfaces, published in 1993 by Microsoft. Wikipedia According to the Wiki article it is the basis for several of Microsofts technologies. One which correlates to the ole libraries we saw, which might be interesting in the context of malware is the possibility for inter process communication and automation provided by ole. These might be used to gain persistence by injecting code in automated startup procedures. ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:3:3","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"Answers There are multiple hits for the sample in its packed as well as in its unpacked version The sample is packed with the sfg (safe, fast good) packer. To unpack it I used the emulation tool unipack. It performed operations usualy done with a debugger to extract the unpacked program code from the sample. After some setup the tool worked and extracted the unpacked program code successfuly The unpacked sample imports the ole32.dll library, which is used to create and control COM Objects. After extracting strings from the unpacked sample I found a web address http://www.malwareanalysisbook.com/ad.html which could be used to monitor for malicious traffic. For host-based indicators I dont know if the interaction with COM Objects might provide a possibility to monitor for malicious activity from the sample on an infected host ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:4:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"PS After finishing my write-up I took a look at the solution provided by the book. Turns out the book didn’t expect you to unpack the sample ¯\\_(ツ)_/¯ ","date":"2023-11-06","objectID":"/2023/11/chapter-one-lab-03/:4:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 3","uri":"/2023/11/chapter-one-lab-03/"},{"categories":["Learning"],"content":"My write up for the analysis of Lab 1 from the first chaptr of Practical Malware Analysis","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"After being interested in the topic of Malware Reversing/Research for a while now and picking Practical Malware Analysis last month. I started working through it this week and, as of now, really enjoying it. The first chapter concentrates on the basics of static analysis of binaries. As the author states himself, a lot of the specifics in the book are now out of date. For example, the Labs are originaly designed for Windows XP. I will be running my static analysis from a Windows 10 VM, as it shouldn’t make much of a difference for static. As soon as we get into dynamic analysis in Chapter 3 I will have a look into extending my virtual lab with a XP machine. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:0:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"So, what are we doing ? The book provides us with a collection of different Labs in the form of binary executable and library files. For each of these we are provided with a list of questions which should act as a guiding path through the analysis. The first Lab actually provides us with 2 Files. An executable (.exe) file and a library file (.dll). Some of the tools suggested by the authori are still a good option, but 10 years after the book’s release there is a lot of new and shiney tools to choose from. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:1:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Tools For the first Lab we will not require a lot of tools. I decided for the following for basic static analysis of the provided file. Detect it easy PE Bear ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:1:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Questions Upload the File to Virustotal. Check if there are existing Anti Virus signatures against this sample. When were the files compiled ? Is there any indication that any of these files is packed or obfuscated ? If so which are those indicators ? Do any imports hint at what this malware does ? If so, which imports are they ? Are there any other files or host-based indicators that you could look for on the infected systems ? What network-based indicators could be used to find this malware on infected machines ? What would you guess is the purpose of these files ? ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:2:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Hashes We use Detect it easy to collect basic information about the files. The first are hashes, which can be used for further reaseach. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable MD5 bb7425b82141a1c0f7d60e5106676bb1 SHA1 9dce39ac1bd36d877fdb0025ee88fdaff0627cdb SHA256 58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL MD5 290934c61de9176ad682ffdd65f0a669 SHA1 a4b35de71ca20fe776dc72d12fb2886736f43c22 SHA256 f50e42c8dfaab649bde0398867e930b86c2a599e8db83b8260393082268f2dba ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Virustotal To avoid uploading irrelevant files to virustotal I used the hashes to search for the files. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable Report 55/72 Vendors detect the file as malicious Imports: Kernel32.dll MSVCRT.dll (entrypoint) Sections: .text .rdata .data the sample gets mostly detected as a Win32 Trojan/Agent Malwarebytes flags the sample as a Systemkiller the sample contacted the following IPs according to VT: 104.86.182.43 104.97.41.163 104.99.238.82 13.107.39.203 13.107.4.50 131.253.33.203 168.62.242.76 178.79.208.1 185.125.188.58 185.125.190.44 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL the sample dll is detected by 45/71 vendors as malicious Imports: Kernel32.dll MSVCRT.dll (entrypoint) WS2_32.dll (network) sections: .text .rdata .data .reloc also mostly recognized as a trojan ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Malware Bazaar Another good source for information on malware is Malware Bazaar. It also gives access to an enormous collection of malware samples. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable Report malware bazaar gives file information which claim the file was delivered via Malspam Figure 1. Malwar Bazaar File information ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL there was no information for the dll hashes on malware bazaar ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Unpac Me Event though Detect it easy tells us the files are not packed, if they were we could use unpac me to check if there are unpacked second stages for files with the same hashes as our executable or dll. Report as we see there is nothing to unpack Figure 2. Unpac me file information ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:6:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Strings ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable String Offset CloseHandle 0x2126 CreateFileA 0x217c CopyFileA 0x21b8 FindFirstFileA 0x21a6 FindNextFileA 0x2196 KERNEL32.dll 0x21c2 malloc 0x21d2 MSVCRT.dll 0x21e2 kerne132.dll 0x3010 kernel32.dll 0x3020 C:\\windows\\system32\\kerne132.dll 0x304c Kernel32. 0x3070 Lab01-01.dll 0x307c C:\\Windows\\System32\\Kernel32.dll 0x308c WARNING_THIS_WILL_DESTROY_YOUR_MACHINE 0x30b0 we can see that the imported dlls we saw in the virustotal report show up in the extracted strings as well we also see that the sample contains strings which reference functions for File Creation with CreateFileA, File Copying with CopyFileA as well as looking through a list of files with FindFirstFileA and FindNextFileA we can also see a string referencing a dll contained in the same directory as the lab executable Lab01-01.dll the name kern132.dll seems curious as it seems like a try at hiding the name by being so similiar to kernel32.dll shortly after that we see a reference to the path C:\\windows\\system32\\kerne132.dll this looks oddly similiar to the actual path to kernel32.dll mentioned later C:\\Windows\\System32\\Kernel32.dll as this sample seems to able to write and copy files we might assume that this sample injects the mention Lab01-01.dll under the fake kernel32.dll path we saw the last extracted string WARNING_THIS_WILL_DESTROY_YOUR_MACHINE is also interesting it might be the reason Malwarebytes flagged the sample as a Systemkiller ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL Offset Size Type String 0000004d 28 A !This program cannot be run in DOS mode. 000001d8 05 A .text 000001ff 07 A `.rdata 00000227 06 A @.data 00000250 06 A .reloc 00001075 05 A L$xQh 000010f9 05 A IQh ` 00001189 06 A L$4PQj 00001354 05 A u7WPS 00001365 05 A u\u0026WVS 0000210a 0b A CloseHandle 00002118 05 A Sleep 00002120 0e A CreateProcessA 00002132 0c A CreateMutexA 00002142 0a A OpenMutexA 0000214e 0c A KERNEL32.dll 0000215c 0a A WS2_32.dll 0000216a 07 A strncmp 00002172 0a A MSVCRT.dll 00002188 09 A _initterm 00002194 06 A malloc 0000219e 0c A _adjust_fdiv 00026018 05 A sleep 00026020 05 A hello 00026028 0d A 127.26.152.13 00026038 08 A SADFHUHF 00027008 0a A /0I0[0h0p0 00027027 0b A 1141G1[1l1 00027039 0b A 1Y2a2g2r22 0002705b 05 A 3!3}3 as we can see there are some function names which seem to be imported by the dll we can also spot an IPv4 address looking string 127.26.152.13 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Inspecting Imports To get a further understanding of which functionality is provided by the files we will look at the imports from the Windows API. We will use PE Bear to inspect the import tables for the executable and the dll. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Exectuable The executable imports a set of Functions from kernel32.dll. Figure 3. PE Bear Import View ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL The dll imports functionality from 2 different dlls. It imports functionality to create a Mutex, a data structure often used by malware to gurantee that only one instance of it runs on a system and it doesn’t re-infect it unnecessaryly. Figure 4 PE Import View The other dll which functions are imported from is ws2_32.dll, a library used for network communication. Figure 5. PE Import View as we can see here the functions imported from ws2_32.dll are not imported by name but by ordinals ordinal numbers are identifiers for functions exported by a dll, when accessing exported functions these can either be referenced by their name or the ordinal number the problem with ordinal numbers used for imports is that these are not consistent across software versions this required me to do some research as the sample is over 10 years old at this point, so I will have to consult an older source for imformation about ws2_32.dll ordinal numbers luckily i found this repository on github which is also about 10 years old, I will try to use this list to determine which functions are imported the code: ordinals = { 'imp_ordinal_1' : 'imp_accept', 'imp_ordinal_2' : 'imp_bind', 'imp_ordinal_3' : 'imp_closesocket', 'imp_ordinal_4' : 'imp_connect', 'imp_ordinal_5' : 'imp_getpeername', 'imp_ordinal_6' : 'imp_getsockname', 'imp_ordinal_7' : 'imp_getsockopt', 'imp_ordinal_8' : 'imp_htonl', 'imp_ordinal_9' : 'imp_htons', 'imp_ordinal_10' : 'imp_ioctlsocket', 'imp_ordinal_11' : 'imp_inet_addr', 'imp_ordinal_12' : 'imp_inet_ntoa', 'imp_ordinal_13' : 'imp_listen', 'imp_ordinal_14' : 'imp_ntohl', 'imp_ordinal_15' : 'imp_ntohs', 'imp_ordinal_16' : 'imp_recv', 'imp_ordinal_17' : 'imp_recvfrom', 'imp_ordinal_18' : 'imp_select', 'imp_ordinal_19' : 'imp_send', 'imp_ordinal_20' : 'imp_sendto', 'imp_ordinal_21' : 'imp_setsockopt', 'imp_ordinal_22' : 'imp_shutdown', 'imp_ordinal_23' : 'imp_socket', 'imp_ordinal_24' : 'imp_GetAddrInfoW', 'imp_ordinal_25' : 'imp_GetNameInfoW', 'imp_ordinal_26' : 'imp_WSApSetPostRoutine', 'imp_ordinal_27' : 'imp_FreeAddrInfoW', 'imp_ordinal_28' : 'imp_WPUCompleteOverlappedRequest', 'imp_ordinal_29' : 'imp_WSAAccept', 'imp_ordinal_30' : 'imp_WSAAddressToStringA', 'imp_ordinal_31' : 'imp_WSAAddressToStringW', 'imp_ordinal_32' : 'imp_WSACloseEvent', 'imp_ordinal_33' : 'imp_WSAConnect', 'imp_ordinal_34' : 'imp_WSACreateEvent', 'imp_ordinal_35' : 'imp_WSADuplicateSocketA', 'imp_ordinal_36' : 'imp_WSADuplicateSocketW', 'imp_ordinal_37' : 'imp_WSAEnumNameSpaceProvidersA', 'imp_ordinal_38' : 'imp_WSAEnumNameSpaceProvidersW', 'imp_ordinal_39' : 'imp_WSAEnumNetworkEvents', 'imp_ordinal_40' : 'imp_WSAEnumProtocolsA', 'imp_ordinal_41' : 'imp_WSAEnumProtocolsW', 'imp_ordinal_42' : 'imp_WSAEventSelect', 'imp_ordinal_43' : 'imp_WSAGetOverlappedResult', 'imp_ordinal_44' : 'imp_WSAGetQOSByName', 'imp_ordinal_45' : 'imp_WSAGetServiceClassInfoA', 'imp_ordinal_46' : 'imp_WSAGetServiceClassInfoW', 'imp_ordinal_47' : 'imp_WSAGetServiceClassNameByClassIdA', 'imp_ordinal_48' : 'imp_WSAGetServiceClassNameByClassIdW', 'imp_ordinal_49' : 'imp_WSAHtonl', 'imp_ordinal_50' : 'imp_WSAHtons', 'imp_ordinal_51' : 'imp_gethostbyaddr', 'imp_ordinal_52' : 'imp_gethostbyname', 'imp_ordinal_53' : 'imp_getprotobyname', 'imp_ordinal_54' : 'imp_getprotobynumber', 'imp_ordinal_55' : 'imp_getservbyname', 'imp_ordinal_56' : 'imp_getservbyport', 'imp_ordinal_57' : 'imp_gethostname', 'imp_ordinal_58' : 'imp_WSAInstallServiceClassA', 'imp_ordinal_59' : 'imp_WSAInstallServiceClassW', 'imp_ordinal_60' : 'imp_WSAIoctl', 'imp_ordinal_61' : 'imp_WSAJoinLeaf', 'imp_ordinal_62' : 'imp_WSALookupServiceBeginA', 'imp_ordinal_63' : 'imp_WSALookupServiceBeginW', 'imp_ordinal_64' : 'imp_WSALookupServiceEnd', 'imp_ordinal_65' : 'imp_WSALookupServiceNextA', 'imp_ordinal_66' : 'imp_WSALookupServiceNextW', 'imp_ordinal_67' : 'imp_WSANSPIoctl', 'imp_ordinal_68' : 'imp_WSANtohl', 'imp_ordinal_69' : 'imp_WSANtohs', 'imp_ordinal_70' : 'imp_WSAProviderConfigChange', 'imp_ordinal_71' : 'imp_WSARecv', 'i","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Answers There are alot of detections for the sample .exe as well as for .dll. As the samples are pretty old (\u003e 10 years) there is a lot of different information that can be found on various Scanner Sites and Sandboxes. Some Information indicate that the executable was, at some point, delivered via a malspam campaign. Most signature hits determine the executable and the dll to be generice Win32 Malware / Trojans Detect it Easy shows Time Date Stamps of 2010-12-19 17:16:19 for the .exe sample and 2010-12-19 17:16:38 for the .dll Looking at the entropy of the files and online unpackers like unpac me they show no indicators that either of the files was packed or obfuscated The imports of the .exe file hint at the fact that its purpose is to write and copy file as well as jump through a list of files. The .dll file imports functions from kernel32.dll to create a process as well as a mutex (a lockable type ) and the sleep. It also imports some functions from ws2_32.dll by their ordinal numbers. After a quick research it seems like the functions exported are the basic functionality used to communicate over the internet with a potential C2-Server. A host-based indicator might be the .dll file coming with the executable Lab01-01.dll The extracted strings from Lab01-01.dll contain an IPv4 address 127.26.152.13 As stated above the provided samples Lab01-01.exe and Lab01-01.dll provide the functionality to write and copy files to the system which hints at some kind of persistence via a file written to disc. Network capabilities and the IP address found might be an indicator that this sample establishes a connection to the C2 to receive further instructions. As the sample also is able to create a new process with CreateProcessA it might be able to receive shellcode from the C2 server which is then ran. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:9:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"My write up for the analysis of Lab 2 from the first chaptr of Practical Malware Analysis","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"As the first writeup got a little bit long, this one will be a little bit shorter. The second lab mainly deals with packing. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:0:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Questions Does the sample match any existing signatures on VT ? Are there indicators that the sample is packed or obfuscated ? If it is packed unpack it if possible. Do any imports hint at the program’s functionality ? Which Imports are there and what do they tell you ? What host and network based indicators could be used to identify this malware on infected machines ? ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:1:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Unpacking Running the file through Detect it easy and PE Bear we see that the sections have weired names like UPX1 and the signature suggests that this file is indeed packed with the upx packer. Figure 1. Detect it easy signature Figure 2. PE Bear Section View Luckily, it is really easy to unpack files packed with upx. All we need to do is to donwload the upx packer program and run the unpack command. .\\upx.exe -d ..\\Lab01-02.exe -o ..\\Lab01-02-unpacked.exe ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:2:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Hashes ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:3:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Packed MD5 8363436878404da0ae3e46991e355b83 Sha1 5a016facbcb77e2009a01ea5c67b39af209c3fcb SHA 256 c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:3:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Unpacked MD5 ae4ca70697df5506bc610172cfc288e7 SHA1 31e8a82e497058ff14049cf283b337ec51504819 SHA256 8bcbe24949951d8aae6018b87b5ca799efe47aeb623e6e5d3665814c6d59aeae ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:3:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Strings ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:4:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Packed Offset Size Type String 004d 28 A !This program cannot be run in DOS mode. 04ab 07 A \" zRV$ 058d 06 A mCDmM 05fb 0a A MalService 0609 07 A sHGL345 0611 08 A http://w 061e 09 A .mwarean 0628 0b A ysisbook.co 0636 17 A om#Int6net Explo!r 8FEI 0663 16 A SystemTimeToFileGetMo 0685 05 A Cvg+ 068b 0c A *Waitab'rEx 069c 07 A Process 06a4 09 A OpenMu$x 06c2 08 A ObjectU4 06dc 05 A [Vrtb 06e5 0b A CtrlDisp ch 072b 07 A -msus 0736 05 A 5nm@_ 073e 06 A t_fd 0769 06 A dlI37n 07db 06 A lB`.rd 0979 09 A `(XPTPSW 0a98 0c A KERNEL32.DLL 0aa5 0c A ADVAPI32.dll 0ab2 0a A MSVCRT.dll 0abd 0b A WININET.dll 0aca 0c A LoadLibraryA 0ad8 0e A GetProcAddress 0ae8 0e A VirtualProtect 0af8 0c A VirtualAlloc 0b06 0b A VirtualFree 0b14 0b A ExitProcess 0b22 0e A CreateServiceA 0b38 0d A InternetOpenA ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:4:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Unpacked Offset Size Type String 004d 28 A !This program cannot be run in DOS mode. 01d8 05 A .text 01ff 07 A `.rdata 0227 06 A @.data 1064 05 A Vh(0@ 1092 05 U @jjjj 216c 0c A KERNEL32.DLL 2179 0c A ADVAPI32.dll 2186 0a A MSVCRT.dll 2191 0b A WININET.dll 21a0 14 A SystemTimeToFileTime 21b6 12 A GetModuleFileNameA 21ca 14 A CreateWaitableTimerA 21e0 0b A ExitProcess 21ee 0a A OpenMutexA 21fa 10 A SetWaitableTimer 220c 13 A WaitForSingleObject 2222 0c A CreateMutexA 2230 0c A CreateThread 223e 0e A CreateServiceA 224e 1b A StartServiceCtrlDispatcherA 226c 0e A OpenSCManagerA 227c 05 A _exit 2284 0b A _XcptFilter 2298 0d A __p___initenv 22a8 0d A __getmainargs 22b8 09 A _initterm 22c4 10 A __setusermatherr 22d6 0c A _adjust_fdiv 22e4 0c A __p__commode 22f2 0a A __p__fmode 22fe 0e A __set_app_type 230e 10 A _except_handler3 2320 0a A _controlfp 232c 10 A InternetOpenUrlA 233e 0d A InternetOpenA 3010 0a A MalService 301c 0a A Malservice 3028 06 A HGL345 3030 22 A http://www.malwareanalysisbook.com 3054 15 A Internet Explorer 8.0 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:4:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Sandboxes [VT Report](VirusTotal - File - c876a332d7dd8da331cb8eee7ab7bf32752834d4b2b54eaa362674a2a48f64a6) Malware Bazaar Unpac Me ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:5:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Imports from the unpacked sample ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:6:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Kernel32.dll # Thunk Ordinal Hint Name 0 0000219e 0000 SystemTimeToFileTime 1 000021b4 0000 GetModuleFileNameA 2 000021c8 0000 CreateWaitableTimerA 3 000021de 0000 ExitProcess 4 000021ec 0000 OpenMutexA 5 000021f8 0000 SetWaitableTimer 6 0000220a 0000 WaitForSingleObject 7 00002220 0000 CreateMutexA 8 0000222e 0000 CreateThread ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:6:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Advapi32.dll # Thunk Ordinal Hint Name 0 0000223c 0000 CreateServiceA 1 0000224c 0000 StartServiceCtrlDispatcherA 2 0000226a 0000 OpenSCManagerA ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:6:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Wininet.dll # Thunk Ordinal Hint Name 0 0000232a 0000 InternetOpenUrlA 1 0000233c 0000 InternetOpenA ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:6:3","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Learning"],"content":"Answers There are existing signatures for the packed as well as for the unpacked sample. Most of them label the sample as generic Win32 malware / Trojan The sections of the PE file being named UPX0 to UPX2 hint at the fact that this sample is packed with upx. Luckily unpacking with UPX is as easy as calling the upx.exe with the right cli flags -d The unpacked sample imports functions from kernel32.dll, advapi32.dll and wininet.dll. The kernel32.dll imports provide functionality for creating threads, creating and opening mutexes, exiting processes, retrieving filepaths for modules loaded by the current process, creating waitable timers and waiting for objects. The advapi32.dll imports functionality for creating a windows service, connecting a service to the ServiceControlDispatcher and opening the service control manager database. The last one requires administrator priviliges or it will fail. The wininet.dll imports provide functionality to initialize usage of the wininet functions and to open a resource via a FTP or HTTP URL. This could mean that the sample will try to create tasks as threads which will be awaited. It might persist by trying to establish itself as a Windows Service which is run on startup. The Network capabilities imported via wininet.dll are a hint that the sample might try to download files or data from a C2 server. A network-based indicator is the URL http://www.malwareanalysisbook.com found in the extracted strings from the unpacked sample. A host-based indicator might be the Windows Service started by the maleware. The unpacked strings contain the names MalService and Malservice which could be the names used for the service created by the malware. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-02/:7:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 2","uri":"/2023/11/chapter-one-lab-02/"},{"categories":["Cheatsheets"],"content":"The basic commands used for debugging with GDB over the Commandline","date":"2023-05-16","objectID":"/2023/05/gdb-basics/","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launching ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:0","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launching against a binary gdb ./path-to-binary ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:1","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launch against a process ID gdb -silent `pidof \u003cbinary-name\u003e` ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:2","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launch in TUI Mode gdb -tui ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:3","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Commands ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:0","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Set breakpoint (gdb) b main // Breaks at main() (gdb) break strcpy // Breaks at strcpy() ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:1","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"List defined breakpoints (gdb) info b ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:2","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Continue execution (gdb) c ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:3","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Step into (gdb) s ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:4","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show stored values (gdb) print $esp (gdb) x/5x $esp-10 // in Hex (gdb) x/5s $esp-10 //String (gdb) x/5d $esp-10 //Decimal (gdb) x/5i $esp-10 //Assembly Instructions ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:5","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show where in the source file we are (gdb) list ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:6","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show where execution is (gdb) where ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:7","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show symbols (gdb) info file ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:8","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show all defined functions (gdb) info functions ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:9","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Show function disassembly (gdb) disas \u003cfunc-name\u003e Example (gdb) disas strcpy Dump of assembler code for function strcpy: 0x42079dd0 \u003cstrcpy+0\u003e: push %ebp 0x42079dd1 \u003cstrcpy+1\u003e: mov %esp,%ebp 0x42079dd3 \u003cstrcpy+3\u003e: push %esi 0x42079dd4 \u003cstrcpy+4\u003e: mov 0x8(%ebp),%esi 0x42079dd7 \u003cstrcpy+7\u003e: mov 0xc(%ebp),%edx 0x42079dda \u003cstrcpy+10\u003e: mov %esi,%eax 0x42079ddc \u003cstrcpy+12\u003e: sub %edx,%eax 0x42079dde \u003cstrcpy+14\u003e: lea 0xffffffff(%eax),%ecx 0x42079de1 \u003cstrcpy+17\u003e: jmp 0x42079df0 \u003cstrcpy+32\u003e 0x42079de3 \u003cstrcpy+19\u003e: nop 0x42079de4 \u003cstrcpy+20\u003e: nop 0x42079dfb \u003cstrcpy+43\u003e: mov %esi,%eax 0x42079dfd \u003cstrcpy+45\u003e: pop %esi 0x42079dfe \u003cstrcpy+46\u003e: pop %ebp 0x42079dff \u003cstrcpy+47\u003e: ret End of assembler dump. ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:2:10","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"}]