[{"categories":["Docs"],"content":"A overview over the basics of Intel x86 Assembly and its most relevant instructions","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"This is an overview over the relevant basics of Intel’s x86 Assembly language. ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:0:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Architecture follows Van Neuman architecture Hardware components: CPU, RAM, I/O bitness: little endian Figure 1. Simplified Hardware Layout ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:1:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Main Memory Layout Data: also called data section, put in place when the program is initially loaded, the values contained in data may not be changed (static) and are available to every part of the program (global) Code: includes the instructions fetched by the CPU to execute the program, controls how the program’s tasks are orchestrated Heap: is used for dynamic memory during execution, changes frequently while the program is running Stack: is used for local variables and function parameters, helps control flow Figure 2. Simplified memory layout ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:2:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Syntax Most instructions are invoked in this format: Mnemonic Destination Source mov ecx 0x42 each instruction corresponds to opcodes ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:3:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Operands operands are used to identify data used by instructions there are 3 types of operands: Immediate operands: fixed values such as 0x42 in the Syntax example Register operands: refer to registers, for example ecx Memory address operands: refer to a memory address which contains value of interest, typically denoted with a value, register or equation in bracktes, like [eax] ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:4:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Registers small amounts of data storage available to the CPU can be accessed more quickly than storage available elsewhere registers on x86 fall into four categories: General registers: used by the CPU during execution Segment registers: used to track sections of memory Status Flags: used to make decisions Instruction Pointers: are used to keep track of the next instruction to execute ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"General Registers EAX (AX AH AL) EBX (BX BH BL) ECX (CX CH CL) EDX (DX DH DL) EBP (BP) ESP (SP) ESI (SI) general registers can either be accessed by their full name to retrieve the full 32-bit of data, but they can also be accessed in 16-bit mode, for example use EDX for all 32-bits in the register and DX to reference the lower 16-bits of the register four of the general registers (EAX, EBX, ECX and EDX) can also be referenced as 8-bit values, for example AL is used to reference the lowest 8-bits of EAX and AH is used to reference the second set of 8-bits, contained in the 16-bit register AX some instructions in x86 use specific registers, for example multiplication and division always use EAX and EDX if general registers are used in a consistent fashion across a program this is known as a convention, knowing different conventions used by different compilers can be helpful during analysis, for example EAX is commonly used to store the return value of a function, so if you see an operation on the EAX register after a call you can assume the return value is manipulated/used further in the code ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:1","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Segment Registers CS SS DS ES FS GS ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:2","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Status Registers EFLAGS the EFLAGS register is a 32-bit status register every bit in it is a flag, it can be set (1) or cleared (0) Figure 3. Layout of the EFLAGS register some important flags: ZF: the Zero Flag is set if the result of an operation is equal to zero, otherwise it is cleared CF: the Carry Flag is set if the result of an operation is too large or too small for the destination operand, otherwise it is cleared SF: the Sign Flag is set when the result of an operation is negative or cleared when the result is positive; is also set when the most significant bit is set after an arithmetic operation TF: the Trap Flag is used for debugging, if the flag is set the x86 processor will only execute one instruction at a time ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:3","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Instruction Pointer EIP also known as instruction pointer or program counter in x86 it is used to store the memory address of the next instruction to be executed tells the processor what to do next ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:5:4","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Instructions A list of some of the most important instructions, what they do and their syntax. ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:0","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"mov used to move data from one location to another Instruction Description mov eax, ebx Copies the content of EBX into the EAX register mov eax, 0x42 Copies the the value 0x42 into the EAX register mov eax, [0x4037C4] Copies the 4 bytes at the memory location 0x4037C4 into the EAX register mov eax, [ebx] Copies the 4 bytes at the memory location specified by the EBX register into the EAX register mov eax, [ebx+esi*4] Copies the 4 bytes at the memory location specified by the result of the equation ebx+esi*4 into the EAX register ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:1","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"lea load effective address format: lea destination, source used to put a memory address into the destination in contrast to mov which moves the content at memory location into the destination example: lea eax, [ebx+8] will put ebx+8 into EAX, while mov eax, [ebx+8] loads the data at the memory address specified by ebx+8 into EAX Figure 4. Difference between mov and lea ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:2","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Docs"],"content":"Arithmetic Addition and Subtraction Instruction Description sub eax, 0x10 Subtracts 0x10 from EAX add eax, ebx Adds EBX to EAX and stores the result in EAX inc edx Increments EDX by 1 dec edx Decrements ECX by 1 Multiplication and Division both always act on predefined registers this requires correct setup of the related registers before the us of the mul or div instructions the syntax for the instruction is mul/div value, as the registers used are already predefined mul and div operate on unsigned value, imul and idiv are their equivalents for operations on signed values Instruction Description mul 0x50 Multiplies EAX by 0x50 and stores the result in EDX:EAX div 0x75 Divides EDX:EAX by 0x75 and stores the result in EAX and the remainder in EDX Multiplication mul always multiplies EAX with the provided value, so EAX needs to be setup correctly before the instruction the result is store as a 64-bit value across EDX and EAX EDX stores the 32 most significant bits and EAX the least significant bits of the return value Division div divides the 64-bits stored across EDX and EAX by value both EDX and EAX must be setup correctly for the use of the instruction the result of the division is stored in EAX and the remainder in EDX the remainder can be accessed with the modulo operator, which will access EDX after running div Logical Operators AND, OR, XOR, SHL, SHR, ROR, ROL for example work like add and sub, perform operation between specified source and destination and storing the result in destination xor can be used as an optimization by the compiler to set a register to 0 by xor it with itself, like xor eax, eax to set EAX to 0, as the instruction only requires 2 bytes instead of 5 for an equivalent mov instruction shl and shr are used to shift registers, their format is shr/shl destination, count they shift the bits in destination left (shl) or right (shr) by the number of bits specified by count bits shifted beyond the boundary are first shifted into CF (Carry Flag Bit), zero bits in the destination are filled in, so after the instruction CF contains the last bit shifted beyond the boundary in comparison ror and rol shift the destination and append the bits going over the boundary are rotated to the other site Instruction Description xor eax, eax Clears the EAX register or eax, 0x7575 Perform the logical or operation on EAX with 0x7575 shl eax, 2 Shifts EAX register to the left 2 bits ror bl, 2 Rotates the BL register to the right 2 bits, fall-off bits will be rotated in to the right ","date":"2023-11-13","objectID":"/2023/11/intel86_assembly/:6:3","tags":["Intel","Assembly","32-bit","x86"],"title":"Intel x86 Assembly Overview","uri":"/2023/11/intel86_assembly/"},{"categories":["Learning"],"content":"My write up for the analysis of Lab 1 from the first chaptr of Practical Malware Analysis","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"After being interested in the topic of Malware Reversing/Research for a while now and picking Practical Malware Analysis last month. I started working through it this week and, as of now, really enjoying it. The first chapter concentrates on the basics of static analysis of binaries. As the author states himself, a lot of the specifics in the book are now out of date. For example, the Labs are originaly designed for Windows XP. I will be running my static analysis from a Windows 10 VM, as it shouldn’t make much of a difference for static. As soon as we get into dynamic analysis in Chapter 3 I will have a look into extending my virtual lab with a XP machine. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:0:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"So, what are we doing ? The book provides us with a collection of different Labs in the form of binary executable and library files. For each of these we are provided with a list of questions which should act as a guiding path through the analysis. The first Lab actually provides us with 2 Files. An executable (.exe) file and a library file (.dll). Some of the tools suggested by the authori are still a good option, but 10 years after the book’s release there is a lot of new and shiney tools to choose from. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:1:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Tools For the first Lab we will not require a lot of tools. I decided for the following for basic static analysis of the provided file. Detect it easy PE Bear ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:1:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Questions Upload the File to Virustotal. Check if there are existing Anti Virus signatures against this sample. When were the files compiled ? Is there any indication that any of these files is packed or obfuscated ? If so which are those indicators ? Do any imports hint at what this malware does ? If so, which imports are they ? Are there any other files or host-based indicators that you could look for on the infected systems ? What network-based indicators could be used to find this malware on infected machines ? What would you guess is the purpose of these files ? ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:2:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Hashes We use Detect it easy to collect basic information about the files. The first are hashes, which can be used for further reaseach. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable MD5 bb7425b82141a1c0f7d60e5106676bb1 SHA1 9dce39ac1bd36d877fdb0025ee88fdaff0627cdb SHA256 58898bd42c5bd3bf9b1389f0eee5b39cd59180e8370eb9ea838a0b327bd6fe47 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL MD5 290934c61de9176ad682ffdd65f0a669 SHA1 a4b35de71ca20fe776dc72d12fb2886736f43c22 SHA256 f50e42c8dfaab649bde0398867e930b86c2a599e8db83b8260393082268f2dba ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:3:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Virustotal To avoid uploading irrelevant files to virustotal I used the hashes to search for the files. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable Report 55/72 Vendors detect the file as malicious Imports: Kernel32.dll MSVCRT.dll (entrypoint) Sections: .text .rdata .data the sample gets mostly detected as a Win32 Trojan/Agent Malwarebytes flags the sample as a Systemkiller the sample contacted the following IPs according to VT: 104.86.182.43 104.97.41.163 104.99.238.82 13.107.39.203 13.107.4.50 131.253.33.203 168.62.242.76 178.79.208.1 185.125.188.58 185.125.190.44 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL the sample dll is detected by 45/71 vendors as malicious Imports: Kernel32.dll MSVCRT.dll (entrypoint) WS2_32.dll (network) sections: .text .rdata .data .reloc also mostly recognized as a trojan ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:4:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Malware Bazaar Another good source for information on malware is Malware Bazaar. It also gives access to an enormous collection of malware samples. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable Report malware bazaar gives file information which claim the file was delivered via Malspam Figure 1. Malwar Bazaar File information ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL there was no information for the dll hashes on malware bazaar ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:5:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Unpac Me Event though Detect it easy tells us the files are not packed, if they were we could use unpac me to check if there are unpacked second stages for files with the same hashes as our executable or dll. Report as we see there is nothing to unpack Figure 2. Unpac me file information ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:6:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Strings ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Executable String Offset CloseHandle 0x2126 CreateFileA 0x217c CopyFileA 0x21b8 FindFirstFileA 0x21a6 FindNextFileA 0x2196 KERNEL32.dll 0x21c2 malloc 0x21d2 MSVCRT.dll 0x21e2 kerne132.dll 0x3010 kernel32.dll 0x3020 C:\\windows\\system32\\kerne132.dll 0x304c Kernel32. 0x3070 Lab01-01.dll 0x307c C:\\Windows\\System32\\Kernel32.dll 0x308c WARNING_THIS_WILL_DESTROY_YOUR_MACHINE 0x30b0 we can see that the imported dlls we saw in the virustotal report show up in the extracted strings as well we also see that the sample contains strings which reference functions for File Creation with CreateFileA, File Copying with CopyFileA as well as looking through a list of files with FindFirstFileA and FindNextFileA we can also see a string referencing a dll contained in the same directory as the lab executable Lab01-01.dll the name kern132.dll seems curious as it seems like a try at hiding the name by being so similiar to kernel32.dll shortly after that we see a reference to the path C:\\windows\\system32\\kerne132.dll this looks oddly similiar to the actual path to kernel32.dll mentioned later C:\\Windows\\System32\\Kernel32.dll as this sample seems to able to write and copy files we might assume that this sample injects the mention Lab01-01.dll under the fake kernel32.dll path we saw the last extracted string WARNING_THIS_WILL_DESTROY_YOUR_MACHINE is also interesting it might be the reason Malwarebytes flagged the sample as a Systemkiller ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL Offset Size Type String 0000004d 28 A !This program cannot be run in DOS mode. 000001d8 05 A .text 000001ff 07 A `.rdata 00000227 06 A @.data 00000250 06 A .reloc 00001075 05 A L$xQh 000010f9 05 A IQh ` 00001189 06 A L$4PQj 00001354 05 A u7WPS 00001365 05 A u\u0026WVS 0000210a 0b A CloseHandle 00002118 05 A Sleep 00002120 0e A CreateProcessA 00002132 0c A CreateMutexA 00002142 0a A OpenMutexA 0000214e 0c A KERNEL32.dll 0000215c 0a A WS2_32.dll 0000216a 07 A strncmp 00002172 0a A MSVCRT.dll 00002188 09 A _initterm 00002194 06 A malloc 0000219e 0c A _adjust_fdiv 00026018 05 A sleep 00026020 05 A hello 00026028 0d A 127.26.152.13 00026038 08 A SADFHUHF 00027008 0a A /0I0[0h0p0 00027027 0b A 1141G1[1l1 00027039 0b A 1Y2a2g2r22 0002705b 05 A 3!3}3 as we can see there are some function names which seem to be imported by the dll we can also spot an IPv4 address looking string 127.26.152.13 ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:7:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Inspecting Imports To get a further understanding of which functionality is provided by the files we will look at the imports from the Windows API. We will use PE Bear to inspect the import tables for the executable and the dll. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Exectuable The executable imports a set of Functions from kernel32.dll. Figure 3. PE Bear Import View ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:1","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"DLL The dll imports functionality from 2 different dlls. It imports functionality to create a Mutex, a data structure often used by malware to gurantee that only one instance of it runs on a system and it doesn’t re-infect it unnecessaryly. Figure 4 PE Import View The other dll which functions are imported from is ws2_32.dll, a library used for network communication. Figure 5. PE Import View as we can see here the functions imported from ws2_32.dll are not imported by name but by ordinals ordinal numbers are identifiers for functions exported by a dll, when accessing exported functions these can either be referenced by their name or the ordinal number the problem with ordinal numbers used for imports is that these are not consistent across software versions this required me to do some research as the sample is over 10 years old at this point, so I will have to consult an older source for imformation about ws2_32.dll ordinal numbers luckily i found this repository on github which is also about 10 years old, I will try to use this list to determine which functions are imported the code: ordinals = { 'imp_ordinal_1' : 'imp_accept', 'imp_ordinal_2' : 'imp_bind', 'imp_ordinal_3' : 'imp_closesocket', 'imp_ordinal_4' : 'imp_connect', 'imp_ordinal_5' : 'imp_getpeername', 'imp_ordinal_6' : 'imp_getsockname', 'imp_ordinal_7' : 'imp_getsockopt', 'imp_ordinal_8' : 'imp_htonl', 'imp_ordinal_9' : 'imp_htons', 'imp_ordinal_10' : 'imp_ioctlsocket', 'imp_ordinal_11' : 'imp_inet_addr', 'imp_ordinal_12' : 'imp_inet_ntoa', 'imp_ordinal_13' : 'imp_listen', 'imp_ordinal_14' : 'imp_ntohl', 'imp_ordinal_15' : 'imp_ntohs', 'imp_ordinal_16' : 'imp_recv', 'imp_ordinal_17' : 'imp_recvfrom', 'imp_ordinal_18' : 'imp_select', 'imp_ordinal_19' : 'imp_send', 'imp_ordinal_20' : 'imp_sendto', 'imp_ordinal_21' : 'imp_setsockopt', 'imp_ordinal_22' : 'imp_shutdown', 'imp_ordinal_23' : 'imp_socket', 'imp_ordinal_24' : 'imp_GetAddrInfoW', 'imp_ordinal_25' : 'imp_GetNameInfoW', 'imp_ordinal_26' : 'imp_WSApSetPostRoutine', 'imp_ordinal_27' : 'imp_FreeAddrInfoW', 'imp_ordinal_28' : 'imp_WPUCompleteOverlappedRequest', 'imp_ordinal_29' : 'imp_WSAAccept', 'imp_ordinal_30' : 'imp_WSAAddressToStringA', 'imp_ordinal_31' : 'imp_WSAAddressToStringW', 'imp_ordinal_32' : 'imp_WSACloseEvent', 'imp_ordinal_33' : 'imp_WSAConnect', 'imp_ordinal_34' : 'imp_WSACreateEvent', 'imp_ordinal_35' : 'imp_WSADuplicateSocketA', 'imp_ordinal_36' : 'imp_WSADuplicateSocketW', 'imp_ordinal_37' : 'imp_WSAEnumNameSpaceProvidersA', 'imp_ordinal_38' : 'imp_WSAEnumNameSpaceProvidersW', 'imp_ordinal_39' : 'imp_WSAEnumNetworkEvents', 'imp_ordinal_40' : 'imp_WSAEnumProtocolsA', 'imp_ordinal_41' : 'imp_WSAEnumProtocolsW', 'imp_ordinal_42' : 'imp_WSAEventSelect', 'imp_ordinal_43' : 'imp_WSAGetOverlappedResult', 'imp_ordinal_44' : 'imp_WSAGetQOSByName', 'imp_ordinal_45' : 'imp_WSAGetServiceClassInfoA', 'imp_ordinal_46' : 'imp_WSAGetServiceClassInfoW', 'imp_ordinal_47' : 'imp_WSAGetServiceClassNameByClassIdA', 'imp_ordinal_48' : 'imp_WSAGetServiceClassNameByClassIdW', 'imp_ordinal_49' : 'imp_WSAHtonl', 'imp_ordinal_50' : 'imp_WSAHtons', 'imp_ordinal_51' : 'imp_gethostbyaddr', 'imp_ordinal_52' : 'imp_gethostbyname', 'imp_ordinal_53' : 'imp_getprotobyname', 'imp_ordinal_54' : 'imp_getprotobynumber', 'imp_ordinal_55' : 'imp_getservbyname', 'imp_ordinal_56' : 'imp_getservbyport', 'imp_ordinal_57' : 'imp_gethostname', 'imp_ordinal_58' : 'imp_WSAInstallServiceClassA', 'imp_ordinal_59' : 'imp_WSAInstallServiceClassW', 'imp_ordinal_60' : 'imp_WSAIoctl', 'imp_ordinal_61' : 'imp_WSAJoinLeaf', 'imp_ordinal_62' : 'imp_WSALookupServiceBeginA', 'imp_ordinal_63' : 'imp_WSALookupServiceBeginW', 'imp_ordinal_64' : 'imp_WSALookupServiceEnd', 'imp_ordinal_65' : 'imp_WSALookupServiceNextA', 'imp_ordinal_66' : 'imp_WSALookupServiceNextW', 'imp_ordinal_67' : 'imp_WSANSPIoctl', 'imp_ordinal_68' : 'imp_WSANtohl', 'imp_ordinal_69' : 'imp_WSANtohs', 'imp_ordinal_70' : 'imp_WSAProviderConfigChange', 'imp_ordinal_71' : 'imp_WSARecv', 'i","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:8:2","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Learning"],"content":"Answers There are alot of detections for the sample .exe as well as for .dll. As the samples are pretty old (\u003e 10 years) there is a lot of different information that can be found on various Scanner Sites and Sandboxes. Some Information indicate that the executable was, at some point, delivered via a malspam campaign. Most signature hits determine the executable and the dll to be generice Win32 Malware / Trojans Detect it Easy shows Time Date Stamps of 2010-12-19 17:16:19 for the .exe sample and 2010-12-19 17:16:38 for the .dll Looking at the entropy of the files and online unpackers like unpac me they show no indicators that either of the files was packed or obfuscated The imports of the .exe file hint at the fact that its purpose is to write and copy file as well as jump through a list of files. The .dll file imports functions from kernel32.dll to create a process as well as a mutex (a lockable type ) and the sleep. It also imports some functions from ws2_32.dll by their ordinal numbers. After a quick research it seems like the functions exported are the basic functionality used to communicate over the internet with a potential C2-Server. A host-based indicator might be the .dll file coming with the executable Lab01-01.dll The extracted strings from Lab01-01.dll contain an IPv4 address 127.26.152.13 As stated above the provided samples Lab01-01.exe and Lab01-01.dll provide the functionality to write and copy files to the system which hints at some kind of persistence via a file written to disc. Network capabilities and the IP address found might be an indicator that this sample establishes a connection to the C2 to receive further instructions. As the sample also is able to create a new process with CreateProcessA it might be able to receive shellcode from the C2 server which is then ran. ","date":"2023-11-05","objectID":"/2023/11/chapter-one-lab-01/:9:0","tags":["Practical Malware Analysis","Writeup","Reverse Engineering","Learning"],"title":"Practical Malware Analysis Chapter 1 Lab 1","uri":"/2023/11/chapter-one-lab-01/"},{"categories":["Cheatsheets"],"content":"The basic commands used for debugging with GDB over the Commandline","date":"2023-05-16","objectID":"/2023/05/gdb-basics/","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launching ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:0","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"},{"categories":["Cheatsheets"],"content":"Launching against a binary gdb ./path-to-binary ","date":"2023-05-16","objectID":"/2023/05/gdb-basics/:1:1","tags":["Cheatsheet","Linux","Debugging"],"title":"GDB Basics Cheatsheet","uri":"/2023/05/gdb-basics/"}]